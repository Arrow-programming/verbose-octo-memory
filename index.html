<!DOCTYPE html>
<!--

My current work in progress
Title: NightArcher

X) Finish coding the player animations
X) Fix collision problem ugh
X) Collisions only detected when the player is close to them
X) Add room changing animation
X) Get that bow to work correctly
X) Change player physics (player should be faster I think...)
X) Maybe should think about loading images to the localStorage
X) Music maybe
X) Redo particles
X) Ask Henry about perlin noise in the grass
X) splice particles when the player changes rooms
X) Player windy death
X) FIX THOSE PLAYER ANIMATIONS
X) Particle fade
X) Room name
X) Idle cloak animation

Ideas haha:
IN DARK MODE THE BLOCKS DON'T SHOW!!!
Cloak mode (player throws cloak over shoulders)

Water: https://www.khanacademy.org/computer-programming/fluid-simulation/5982208821477376

https://stackoverflow.com/questions/3768565/drawing-an-svg-file-on-a-html5-canvas

Log: 
4/16/2024: Finished up player walking animation and image cache
5/10/2024: Fixed image opacity thanks to Henry. Fixed air walking. Not so sure about jumping abilities. Should the player be able to walk in the air? Started work on angled jump (angular velocity seems to work best)
7/10/2024: Redid jumping, resumed work for the summer. Still working on physics
1/20/2025: This is in development again! 

Henry, Pixel Imperfect, The Dark, CZS, The Duke, HR. 

https://www.khanacademy.org/computer-programming/i/6255462600146944

-->
<html>
    <head>
        <!--Encoding and viewport-->
	    <meta charset="utf-8">
	    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!--Import google font: Exo -->
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Exo">
        <link rel='stylesheet' href='https://fonts.googleapis.com/css2?family=Lato&family=Material+Icons&display=swap'>
        <!--The page title-->
        <title>New Webpage</title>
        <!--CSS Styling-->
        <style>
            * {
                transition: 1s;
            }
            script {
                font-family: Pixelify Sans;
                color: black;
            }
            body {
                width: 100vw;
                height: 100vh;
                margin: 0;
                padding: 0;
                overflow: hidden;
                align-items: center;
                transition: 0s;
                
            }
            a {
                display: inline-block;
                position: relative;
                color: rgb(255, 255, 255);
                text-decoration: none;
            }
            
            a::before {
                content: "";
                position: absolute;
                width: 100%;
                height: 2px;
                bottom: 0;
                left: 0;
                background-color: rgb(255, 255, 255);
                visibility: hidden;
                transform: scaleX(0);
                transition: all 0.3s ease-in-out 0s;
            }
            
            a:hover::before {
                visibility: visible;
                transform: scaleX(1);
            }
            
            canvas {
    			
    		}
		
    		canvas:focus {
    			outline: none;
    		}
            
            #container {
                position: relative;
                color: black;
                left: 0%;
            }
            
            #container canvas, #overlay {
                position: absolute;
            }
            
            #fullscreen-container {
                position: absolute;
                left: 555px;
                top: 5px;
            }
            
    		#fullscreen {
    		    color: white;
    			font-size: 28px;
    			border-radius: 50%;
    			padding: 5px;
    			box-sizing: border-box;
    			cursor: pointer;
    			transition: background 200ms;
    		    position: relative;
    		    float: right;
    		    
    		}
    		#fullscreen:hover {
    			background: #fff2;
    		}
        </style>
    </head>
    <body>
        <!--The container for the entire thing-->
        <div id= "container">
            <canvas id = "game"></canvas>
            <div id = "overlay">
                <!--<div id = "fullscreen-container">
                    <span class='material-icons' id='fullscreen'>fullscreen</span>
                </div>-->
            </div>
        </div>
    </body>
    <script>
        //fetch HTML Canvas
        var canvas = document.getElementById("game"); 
        var ctx = canvas.getContext('2d'); 
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        var width = canvas.width;
        var height = canvas.height;
    </script>
    <script type>
        //My HTML5 Canvas engine. Combines some elements of HTML Canvas into functions to make it more compactable and easier to work with. Feel free to use with credit. Note that this isn't in ES6 because you can't have two modules.
        
        //is stroke or fill on?
        var Stroke = true;
        var Fill = true;
        
        var keys = {};
        var mouse = {
            x: 0,
            y: 0,
            clicked: false,
            released: false,
            down: false,
        };
        
        var EL = window.addEventListener;
        var frameCount = 0;
        
        //Convert a angle to radians
        function dR(degrees){
            var pi = Math.PI;
            return degrees * (pi/180);
        }
        
        //convert a angle to radians
        function rD(radians){
            var pi = Math.PI;
            return radians * (180/pi);
        }
        
        //Trigonomic functions
        function sin(a){
            return Math.sin(dR(a));
        }
        function cos(a){
            return Math.cos(dR(a));
        }
        function tan(a){
            return Math.tan(dR(a));
        }
        function abs(a){
            return Math.abs(a);
        }
        function atan(a){
            return rD(Math.atan(a));
        }
        function atan2(a, b){
            return rD(Math.atan2(a, b));
        }
        
        //round a number
        function round(a){
            return Math.round(a);
        }
        
        //The square root of a number
        function sqrt(a){
            return Math.sqrt(a);
        }
        
        //a to the power of b
        function pow(a, b){
            return Math.pow(a, b);
        }
        
        //Rounding methods
        function ceil(a){
            return Math.ceil(a);
        }
        function floor(a){
            return Math.floor(a);
        }
        
        //The sign of a num
        function sign(x) {
            return (abs(x) / x) || 0;
        }
        
        //returns the random value of a min and max number
        function random(min, max) {  
            return Math.random() * (max - min + 1) + min;
        }
        
        //Calculates a number between two numbers at a specific increment
        function lerp(num1, num2, amt) {
        	return num1 + (num2 - num1) * amt;
        }
        
        //Re-maps a number from one range to another.
        function map(num, start1, stop1, start2, stop2) {
        	return start2 + (num - start1) / (stop1 - start1) * (stop2 - start2);
        }
        
        //Constrains a value to not exceed a maximum and minimum value.
        function constrain(num, min, max) {
        	return Math.max(Math.min(num, max), min);
        }
        
        //Calculates the distance between two points
        function dist(x1, y1, x2, y2) {
        	return Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
        }
        
        //Finds a midpoint
        function midpoint(Ax, Bx, Ay, By){
            var mx = (Ax + Bx)/2;
            var my = (Ay + By)/2;
            
            return [mx, my];
        }
        
        //Maps a point to a line where percentage is line length
        function mapToLine(x1, y1, x2, y2, percentage) {
            return {
                x : x1 * (1.0 - percentage) + x2 * percentage, 
                y : y1 * (1.0 - percentage) + y2 * percentage
            };
        }
        
        //Color methods
        function fill(n) {
        	Fill = true;
        	ctx.fillStyle = n;
        }
        function stroke(str) {
        	Stroke = true;
        	ctx.strokeStyle = str;
        }
        function noStroke() {
        	Stroke = false;
        }
        function noFill() {
        	Fill = false;
        }
        function strokeWeight(s) {
        	ctx.lineWidth = s;
        }
        function strokeCap(cap) {
        	ctx.lineCap = cap;
        }
        function background(color){
            fill(color);
            ctx.fillRect(0, 0, width, height);
        };
        
        //Transformations
        function translate(x, y) {
        	ctx.translate(x, y);
        }
        function scale(a, b) {
        	if (b === undefined) {
        		ctx.scale(a, a);
        		return;
        	}
        	ctx.scale(a, b);
        }
        function rotate(angle) {
        	ctx.rotate(angle / 180 * Math.PI);
        }
        function pushMatrix() {
        	ctx.save();
        }
        function popMatrix() {
        	ctx.restore();
        }
        
        //Complex shapes
        function beginShape() {
        	ctx.beginPath();
        }
        function endShape() {
        	if (Fill) {
        		ctx.fill();
        	}
        	if (Stroke) {
        		ctx.stroke();
        	}
        }
        function vertex(x, y) {
        	ctx.lineTo(x, y);
        }
        function curveVertex(cx, cy, x, y) {
        	ctx.quadraticCurveTo(cx, cy, x, y);
        }
        function quad(x1, y1, x2, y2, x3, y3, x4, y4) {
        	beginShape();
        	vertex(x1, y1);
        	vertex(x2, y2);
        	vertex(x3, y3);
        	vertex(x4, y4);
        	vertex(x1, y1);
        	endShape();
        }
        function triangle(x1, y1, x2, y2, x3, y3) {
        	beginShape();
        	vertex(x1, y1);
        	vertex(x2, y2);
        	vertex(x3, y3);
        	vertex(x1, y1);
        	endShape();
        }
        function bezierVertex(cx1, cy1, cx2, cy2, x, y) {
        	ctx.bezierCurveTo(cx1, cy1, cx2, cy2, x, y);
        }
        function bezier(x1, y1, cx1, cy1, cx2, cy2, x2, y2) {
        	ctx.beginPath();
        	    ctx.moveTo(x1, y1);
        	    bezierVertex(cx1, cy1, cx2, cy2, x2, y2);
            ctx.stroke();
        }
        function line(x1, y1, x2, y2) {
        	beginShape();
        	vertex(x1, y1);
        	vertex(x2, y2);
        	endShape();
        }
        //A point (Circles take more processing)
        function point(x, y, s) {
            if(s === undefined){
                ctx.fillRect(x, y, 2, 2);
            }
        	ctx.fillRect(x, y, s, s);
        }
        //rectangle (derived from GGScript v3.1: https://www.khanacademy.org/computer-programming/i/6574217842966528)
        function rect(x, y, w, h, r, r2, r3, r4) {
        	r = r || 0;
        	r = constrain(r, -Math.min(w, h) / 2, Math.min(w, h) / 2);
        	if (r2 === undefined || r3 === undefined || r4 === undefined) {
        		r2 = r;
        		r3 = r;
        		r4 = r;
        	}
        	r2 = constrain(r2, -Math.min(w, h) / 2, Math.min(w, h) / 2);
        	r3 = constrain(r3, -Math.min(w, h) / 2, Math.min(w, h) / 2);
        	r4 = constrain(r4, -Math.min(w, h) / 2, Math.min(w, h) / 2);
        	beginShape();
        	ctx.moveTo(x, y + r);
        	curveVertex(x, y, x + r, y);
        	vertex(x + w - r2, y);
        	curveVertex(x + w, y, x + w, y + r2);
        	vertex(x + w, y + h - r3);
        	curveVertex(x + w, y + h, x + w - r3, y + h);
        	vertex(x + r4, y + h);
        	curveVertex(x, y + h, x, y + h - r4);
        	vertex(x, y + r);
        	endShape();
        }
        //Arcs and circles
        function arcTo(x, y, r, start, stop) {
        	ctx.arc(x, y, r / 2, start / 180 * Math.PI, stop / 180 * Math.PI);
        }
        function arc(x, y, w, h, start, stop) {
        	pushMatrix();
        	translate(x, y);
        	scale(1, h / w);
        	beginShape();
        	arcTo(0, 0, w, start, stop);
        	endShape();
        	popMatrix();
        }
        function ellipse(x, y, w, h) {
        	w = Math.abs(w);
        	h = Math.abs(h);
        	arc(x, y, w, h, 0, 360);
        }
        
        //Change cursor
        function cursor(name) {
        	document.body.style.cursor = name;
        }
        
        //text
        function text(txt, x, y){
            ctx.fillText(txt, x, y);
        }
        function font(n){
            ctx.font = n;
        }
        
        //Add key events
        EL('keydown', (e) => {
            e.preventDefault();
            keys[e.which] = true;
        });
        EL('keyup', (e) => {
            e.preventDefault();
            keys[e.which] = false;
        });
        //add mouse events
        EL('click', (e) => {
            //e.preventDefault();
            mouse.clicked = true;
        });
        EL('mouseup', (e) => {
            //e.preventDefault();
            mouse.released = true;
            mouse.down = false;
        });
        EL('mousedown', (e) => {
            //e.preventDefault();
            mouse.down = true;
        });
        EL('mousemove', (e) => {
            //e.preventDefault();
            mouse.x = e.clientX,
            mouse.y = e.clientY;
        });
        
        //enableContextMenu
        EL('oncontextmenu', (e) => {
            return true;
        });
    </script>
    <script type = "module">
try {
    
    //collect and delete animation frames that have already occured 
    for(let i = window.requestAnimationFrame(function() {}); i > 0; i--) {
        window.cancelAnimationFrame(i);
    }
    
    noStroke();
    ctx.lineCap = "round";
    
    //dev
    let err = "";
    let txt = 0 || "";
    
    let cam;
    
    //frameCounter for animations
    let frameCount = 0;
    
    //block size and storage. 10x10 seems reasonable...
    let blocks = [];
    const blockSize = 10;
    
    //a three dimensional array
    const CAVERNS = [
    //NOTE: Levels are somehow a perfect 100 by 100 pixels. This is useful for troubleshooting   
        /** 
        
        0, 1
        2, 3
        
        **/
    [  
        //0
        [
            "#########    #######",
            "#########     ######",
            "########        ####",
            "#######          ###",
            "#######          ###",
            "######           ###",
            "#####            ###",
            "###              ###",
            "##               ###",
            "##               ###",
            "##               ###",
            "##                ##",
            "##                ##",
            "##                 #",
            "##                 ",
            "##                  ",
            "##                  ",
            "########            ",
            "###########         ",
            "####################",
        ],  
        //1
        [
            "########################",
            "########           #####",
            "########             ###",
            "#######                #",
            "######                 ",
            "#####                  ",
            "#####                  ",
            "###                    ",
            "###                    ",
            "##                     ",
            "#                      ",
            "#                      ",
            "#                      ",
            "#                      ",
            "                       ",
            "                       ",
            "                       ",
            "                       ",
            "                       ",
            "########################",
        ], 
        
        [
            "                   ",
            "                    ",
            "                    ",
            "                    ",
            "                    ",
            "                    ",
            "                    ",
            "                    ",
            "                    ",
            "                    ",
            "                    ",
            "                    ",
            "                    ",
            "                    ",
            "                    ",
            "                    ",
            "                    ",
            "                    ",
            "                    ",
            "####################",
        ],
    ],  
    [    
        //2
        [
            "##############  ####",
            "#                  #",
            "#                  #",
            "####            ####",
            "########       #   #",
            "#########     #    #",
            "###########        #",
            "#                  #",
            "#                  #",
            "#             ######",
            "#            #     #",
            "#           #      #",
            "#          #       #",
            "#  ####            #",
            "#      #           #",
            "#       #           ",
            "#        #          ",
            "#         #         ",
            "#          #        ",
            "#                  #",
            "#                  #",
            "#                  #",
            "#      #############",
            "#                  #",
            "#                  #",
            "####################",
        ],
        //3
        [
            "#######     #################",
            "#                           #",
            "#                           #",
            "#        ###                #",
            "#       #                   #",
            "#                           #",
            "#                           #",
            "#---#                       #",
            "########                    #",
            "#  #######                  #",
            "#      ####       ###########",
            "#                 #####     #",
            "#                ##         #",
            "#              ####         #",
            "#         #######           #",
            "#          # #              #",
            "        ######              #",
            "          #  #              #",
            "     #########--------------#",
            "#############################",
        ],  
    ],
        
        /**[
            "####################",
            "#                  #",
            "#                  #",
            "#                  #",
            "#                  #",
            "#                  #",
            "#                  #",
            "#                  #",
            "#                  #",
            "#                  #",
            "#                  #",
            "#                  #",
            "#                  #",
            "#                  #",
            "#                  #",
            "#                  #",
            "#                  #",
            "#                  #",
            "#@                 #",
            "####################",
        ],  **/
    ];
    const NEWMAP = [];
    
    //the world colors
    const col = {
        //background
        bg: "rgb(0, 0, 0)",
        //overlay
        bgOver: "rgba(255, 255, 255, 0.2)",
        //player
        p:{    
            skinColor: "rgb(255, 225, 148)",  
            bow: "rgb(92, 61, 5)",
            cloths: "rgb(46, 97, 63)",
            cloak: "rgb(92, 66, 45)",
            cloakRear: "rgb(51, 33, 20)",
            rear: "rgb(13, 69, 32)",
            front: "rgb(56, 135, 82)", 
        },
        //blocks
        bl:{
            block: "rgb(65, 65, 100)",
            block2: "rgb(50, 50, 100)",
            grass: "rgb(135, 95, 64)",
            poison: "rgb(127, 255, 129)",
            pipe1: "rgb(161, 161, 161)",
            pipe2: "rgb(115, 115, 115)",
        },
        wind: "rgba(255, 255, 255, 0.5)",
    };
    
    //the level input string and starting map
    let LEVEL = "";
    
    //the players current row and column in the World
    let curRow = 0;
    let curColumn = 0;
    let curMap = CAVERNS;
    
    //size storage for length of levels in pixels
    let lvlSizeX = 0;
    let lvlSizeY = 0;
     
    //critical functions, room changing, death animation
    const functions = {
        active: false,
        started: false,
        plUpdate: true,
        
        left: false,
        right: false,
        top: false,
        bottom: false,
        
        startPos: {
            row: 0,
            col: 0,
            x: 50,
            y: 150,
        },
        plCoord: {
            x: 0,
            y: 0,
        },
        
        deathTimer: 10,
        deathTimerStart: 10,
        checkColl: function(player){
            if(player.x < (0 - player.w/2)){
                this.left = true;
                this.started = true;
            }
            if(player.x > (lvlSizeX - player.w/2)){
                this.right = true;
                this.started = true;
            }
            if(player.y < (0 - player.h/2)){
                this.top = true;
                this.started = true;
            }
            if(player.y > (lvlSizeY + player.h/2)){
                this.bottom = true;
                this.started = true;
            }
            return this.checkColl;
        },
        leftRoom: function(player){
            return curColumn -= 1;
        },
        rightRoom: function(player){
            return curColumn += 1;
        },
        topRoom: function(player){
            return curRow -= 1;
        },
        bottomRoom: function(player){
            return curRow += 1;
        },
        storePlayerCoords: function(player){
            this.plCoord.x = player.x;
            this.plCoord.y = player.y;
        },
        execute: function(player){
            this.checkColl(player);
            //this.started is a closure. It only allows the wrapped commands to be executed once. This is important when dealing with increments and decrements
            if(this.started){
                if(this.top){
                    this.storePlayerCoords(player);
                    this.topRoom(player);
                    LEVEL = curMap[curRow][curColumn];
                    mapSetup(LEVEL);
                    player.x = this.plCoord.x;
                    player.y = lvlSizeY - player.h;
                    this.top = false;
                    this.started = false;
                }
                if(this.bottom){
                    this.storePlayerCoords(player);
                    this.bottomRoom(player);
                    LEVEL = curMap[curRow][curColumn];
                    mapSetup(LEVEL); 
                    player.x = this.plCoord.x;
                    player.y = 0;
                    this.bottom = false;
                    this.started = false;
                }
                if(this.left){
                    this.storePlayerCoords(player);
                    this.leftRoom(player);
                    LEVEL = curMap[curRow][curColumn];
                    mapSetup(LEVEL);
                    player.x = lvlSizeX - player.w;
                    player.y = this.plCoord.y;
                    this.left = false;
                    this.started = false;
                }
                if(this.right){
                    this.storePlayerCoords(player);
                    this.rightRoom(player);
                    LEVEL = curMap[curRow][curColumn];
                    mapSetup(LEVEL);
                    player.x = 5;
                    player.y = this.plCoord.y;
                    this.right = false;
                    this.started = false;
                }
            }
            
            //err = "row: " + curRow + "\n col: " + curColumn;
            
            //on death
            if(player.die){
                this.deathTimer--;
                //err = this.deathTimer;
                this.plUpdate = false;
                var xPos = (player.x + player.xOff) * cam.z - cam.x + cam.align.x - 30;
                var yPos = (player.y + player.yOff) * cam.z - cam.y + cam.align.y - 180;
                var img = ctx.getImageData(xPos, yPos, 100, 100);
                //ctx.putImageData(img, 200, 200, 0, 0, 100, 100);
                
                
                //player goes to restart place
                if(this.deathTimer <= 0){
                    LEVEL = curMap[this.startPos.row][this.startPos.col];
                    player.x = this.startPos.x;
                    player.y = this.startPos.y;
                    curRow = this.startPos.row;
                    curColumn = this.startPos.col;
                    mapSetup(LEVEL);
                    this.deathTimer = this.deathTimerStart;
                    this.plUpdate = true;
                    //always make sure to call the flag last
                    player.die = false;
                }
            }
        },
    };
    
    //the image cache. Loads images into the canvas. 
    const imagesToLoad = [
        {
            display : function() { 
                noStroke();
                for(var j = 0; j < height; j++){
                    for(var i = 0; i < width; i++){
                        fill(col.bgOver);
                        if(Math.floor(random(0, 1))){
                            ctx.fillRect(j * 2.5, i * 2.5, 2.5, 2.5);
                        }
                        ///txt = value;
                    }        
                }
            }, 
            w : width,
            h : height,
        }, 
        {
            display : function() {
                
            }, 
            w : 600,
            h : 600
        }
    ];
    var Cache = (function() {
        Cache = function(that) {
            this.loaded = false;
            this.imgIndex = 0;
            this.curImg = {};
            this.img = [];
        };
        Cache.prototype = {
            load: function() {
                if (this.imgIndex < imagesToLoad.length) {
                    (async() => {
                        this.curImg = imagesToLoad[this.imgIndex];
                        this.curImg.display();
                        let imageData = ctx.getImageData(
                            0, 0, this.curImg.w, this.curImg.h
                        );
                        
                        for (let i = 3; i < imageData.data.length; i += 4) {
                            imageData.data[i] = 0.2 * 255;                               }
                        const bmp = await createImageBitmap(imageData);
                        this.img.push(bmp);
                        this.imgIndex++;
                    })();
                } 
                else { 
                    this.loaded = true;
                }
            }
        };
        return Cache;
    })(); 
    const cache = new Cache();
    function img(that, x, y){
        if(cache.loaded){
            return ctx.drawImage(that, x, y);
        }
    }
    
    //camera shake
    const shakes = []; 
    let shake = {
        x: 0,
        y: 0,
    };
    const Shake = (function () {
        let Shake = function (n) {
            //shake power
            this.n = n;
        };
        Shake.prototype = {
            active: function(increment){
                //apply shake
                shake.x = (Math.random()*2-1)*this.n;
                shake.y = (Math.random()*2-1)*this.n;
                
                //fade the shake
                this.n -= 0.5;
                
                if (this.n < 0) {
                    shake.x = 0;
                    shake.y = 0;
                    shakes.splice(increment, 1);
                }
            }
        };
        return Shake;
    })();
    
    //define a Particle
    const Particle = (function () {
        const Configure = function (config) {
            this.position = config.position || Object;
            this.size = config.size || 10;
            this.color = config.color;
            this.velocity = config.velocity || Object;
            //the lifetime of a particle is directly equal to the amount of particles active, cool right?
            this.life = config.life || 100;
            this.acceleration = config.acceleration || Object;
            this.angle = config.angle || 0;
            this.rotation = config.rotation || 0;
            this.opacity = config.opacity;
            this.clear = config.clear || false;
        };
        Configure.prototype = {
            addVelocity: function(){
                this.position.x += this.velocity.x;
                this.position.y += this.velocity.y;
            },
            addAcceleration: function(){
                this.velocity.x += this.acceleration.x;
                this.velocity.y += this.acceleration.y;
            },
            update: function(){
                this.addVelocity();
                this.addAcceleration();
                this.angle += this.rotation;
                if(this.clear !== false){
                    
                    this.opacity = this.life;
                }
                else {
                    this.opacity = 1;
                }
            },
            draw: function () {
                pushMatrix();
                    noStroke();
                    
                    translate(this.position.x + this.size / 2, this.position.y + this.size / 2);
                    rotate(this.angle);
                    ctx.globalAlpha = this.opacity;
                    fill(this.color, this.life * 3);
                    rect(-this.size / 2, -this.size / 2, this.size, this.size);
                popMatrix();
            },
            die: function(){
                return this.life < 0;
            },
            run: function(){
                this.life--;
                this.draw();
                this.update();
            },
        };
        return Configure;
    })();
    const ParticleSystem = (function () {
        const Configure = function (config) {
            this.add = config.add || function() {};
            //each system has its own array of particles
            this.particles = [];
        };
        Configure.prototype = {
            addParticle: function(){
                this.add();
            },
            run: function(){
                //scrap object if particles not being added
                if(!this.add){
                    this.addParticle();
                }
                for (let i = this.particles.length-1; i >= 0; i--) {
                    this.particles[i].run();
                    if (this.particles[i].die()) {
                        this.particles.splice(i, 1);
                    }
                }
                
            },
        };
        return Configure;
    })();
    const poisonParticles = new ParticleSystem({
        add: function(x, y, w, h){
            if((Math.random(2)*2-1) > 0.97){
                this.particles.push(new Particle({
                    position: {
                        x: random(x, x + w),
                        y: y
                    },
                    velocity: {
                        x: random(-0.5, 0.5),
                        y: random(-1, -3)
                    },
                    size: 1.5,
                    color: col.bl.poison,
                    opacity: 1,
                    life: 30,
                    acceleration: {
                        x: 0,
                        y: 0.08,
                    },
                    angle: 60,
                    rotation: random(4, 7) * -random(1, 2),
                    clear: true,
                }));
            }
        },
    }),
          poisonStream = new ParticleSystem({
            add: function(x, y, xVel, lifeTime){
                this.particles.push(new Particle({
                    position: {
                        x: x,
                        y: y
                    },
                    velocity: {
                        x: xVel,
                        y: random(-0.5, -1)
                    },
                    size: random(1, 4),
                    color: col.bl.poison,
                    opacity: 1,
                    life: lifeTime,
                    acceleration: {
                        x: 0,
                        y: 0.08,
                    },
                    angle: 60,
                    rotation: random(4, 7) * -random(1, 2),
                    clear: false,
                    
                }));
            },
          }),
          wind = new ParticleSystem({
            add: function(x, y){
                if((Math.random(2)*2-1) > 0.30){
                    this.particles.push(new Particle({
                        position: {
                            x: width + 5,
                            y: random(0, height)
                        },
                        velocity: {
                            x: -0.5,
                            y: random(-0.5, -1)
                        },
                        size: random(1, 5),
                        color: col.wind,
                        opacity: 1,
                        life: 150,
                        acceleration: {
                            x: -0.05,
                            y: 0.0,
                        },
                        angle: 60,
                        rotation: random(4, 7) * -random(1, 2),
                        clear: false,
                        
                    }));
                }
            },
          });
            
    //collisions
    const Physics = (function(){
        const correction = 1;
        const collideBox = {
            top: function(a, b){
                if ((a.x + a.w / 2 - correction) > b.x - a.w / 2 && (a.x) < (b.x + b.w - 3) && (a.y + a.h) > b.y && (a.y < b.y - 3)) {
                    return true;
                }
            },
            bottom: function(a, b){
                if ((a.x + a.w / 2 - correction) > b.x - a.w / 2 && (a.x) < (b.x + b.w - 3) && (a.y + a.h) > b.y && (a.y < b.y + b.h)) {
                    return true;
                }
            },
            right: function(a, b){
                if ((a.x) > b.x - a.w / 2 && (a.x) < (b.x + b.w) && (a.y + a.h - correction) > b.y && (a.y < b.y + b.h)) {
                    return true;
                }
            },
            left: function(a, b){
                if ((a.x + a.w / 2) > b.x - a.w / 2 && (a.x) < (b.x) && (a.y + a.h - correction) > b.y && (a.y < b.y + b.h)) {
                    return true;
                }  
            },
            all: function(a, b){
                if(this.top(a, b)){
                    a.v.y = 0;
                    a.jump = true;
                    a.y = b.y - a.h;
                }
                if(this.bottom(a, b)){
                    a.v.y = 0;
                    a.y = b.y + b.h;
                }
                if(this.right(a, b)){
                    a.v.x = 0;
                    a.x = b.x + b.w;
                }
                if(this.left(a, b)){
                    a.v.x = 0;
                    a.x = b.x - a.w;
                }
            },
            touch: function(a, b){
                return a.x + a.w > b.x && a.x < b.x + b.w && a.y + a.h > b.y && a.y < b.y + b.h;
            }
        };
        return {
            collideBox: collideBox,
        };
    })();
    
    //the player
    const player = {
        //positioning and vector movement
        scale: 0.25,
        xOff: 6,
        yOff: 52,
        x: 0, y: 0,
        w: 10, h: 20,
        v: {
            x: 0,
            y: 0,
        },
        jump: false,
        
        die: false,
        
        //graphical animations
        index: 0,
        walk: [
            [7, 18, -23, 5], 
            [-28, 75, -9, 5],
            [-44, 75, 3, 5],
            [-23, 5, 7, 18], 
            [-9, 5, -28, 75],  
            [3, 5, -44, 75],  
        ],
        walkArms: [
            [-10, -39, 21, 0],
            [-22, -20, -4, 4],
            [22, -29, -22, -10],
            [23, -1, -6, -48],
            [-4, 4, -14, -37],
            [-26, 8, 16, -17],
        ],
        idle: [3, 10, -10, 5],
        air: [-20, 90, -30, 90],
        pos: [0, 0, 0, 0],
        idleArms: [4, -70, -9, 15],
        posArms: [-10, -39, 21, 0],
        action: "idle",
        dir: 1,
        animSpeed: 0.125,
        emphasis: 1.4,
        
        hasBow: true,
        
        physics: {
            acc: 0.03,
            friction: 1.1,
            jumpPow: 2.88,
            gravity: 0.08,
            speed: 0.7,
        },
        
        shoot: false,
        top: false,
        followMouse: false,
        leg1: function(t1, k1, t2, k2, x, y){
            noStroke();
            //rear leg
            fill(col.p.rear);
            pushMatrix();
                translate(x, y);
                rotate(t2);
                rect(-5 * this.scale, 0, 10 * this.scale, 25 * this.scale, 5 * this.scale);
                translate(0, 20  * this.scale);
                rotate(k2);
                rect(-5 * this.scale, 0, 10  * this.scale, 20 * this.scale, 3 * this.scale);
                fill(col.p.cloakRear);
                rect(-5 * this.scale, 1, 10 * this.scale, 20 * this.scale, 3 * this.scale);
                rect(-5 * this.scale, 4, 14 * this.scale, 7 * this.scale, 3 * this.scale);
            popMatrix();
        },
        leg2: function(t1, k1, t2, k2, x, y){
            noStroke();
            //front leg
            fill(col.p.front);
            pushMatrix();
                translate(x, y);
                rotate(t1);
                rect(-5  * this.scale, 0, 10  * this.scale, 25  * this.scale, 5 * this.scale);
                translate(0, 20 * this.scale);
                rotate(k1);
                rect(-5 * this.scale, 0, 10 * this.scale, 20 * this.scale, 3 * this.scale);
                fill(col.p.cloak);
                rect(-5 * this.scale, 1, 10 * this.scale, 20 * this.scale, 3 * this.scale);
                rect(-5 * this.scale, 4, 14 * this.scale, 7 * this.scale, 3 * this.scale);
            popMatrix();
        },
        bow: function(x, y, pow, ANGLE){
            pushMatrix();
                translate(x, y - pow + -13);
                // var x = (mouseX - x - this.x);
                // var y = (mouseY - y - this.y);
                // var angle = atan2(y, x);
                //rotate(angle + 45);
                rotate(ANGLE);
                const zed = mapToLine(-16  * this.scale, 20 * this.scale, 16 * this.scale, -20 * this.scale, pow);
                var x = zed.x;
                var y = zed.y;
                noFill(); strokeWeight(4 * this.scale); stroke(col.p.bow);
                strokeCap(100);
                bezier(-20 * this.scale, -14 * this.scale, x * pow * this.scale, y * pow * this.scale, x * pow * this.scale, y * pow * this.scale, 16 * this.scale, 20 * this.scale);
            popMatrix();
        },
        arm1: function(t1, k1, t2, k2, x, y){
            noStroke();
            //front arm
            pushMatrix();
                translate(x, y);
                
                if(!this.hasBow){
                    rotate(t1);
                }
                
                fill(col.p.front);
                rect(-5 * this.scale, 0, 10 * this.scale, 25 * this.scale, 5 * this.scale);
                
                
                translate(0, 5);
                if(!this.hasBow){
                    rotate(k1);
                }
                
                //bow
                //{
                var xPos = (player.x + player.xOff) * cam.z - cam.x + cam.align.x;
                var yPos = (player.y + player.yOff) * cam.z - cam.y + cam.align.y - 138;

                var angle = atan2(-this.dir * (mouse.x - xPos), mouse.y - yPos);
                
                if(this.hasBow){
                    if(this.shoot){
                        rotate(angle);
                    }
                    else {
                        rotate(k1);
                    }
                    
                    //-0.35 max
                    this.bow(0, 17, -0.20, 145);
                
                }
                //}
                
                noStroke();
                fill(col.p.skinColor);
                ellipse(0 * this.scale, 16 * this.scale, 8 * this.scale, 8 * this.scale);
                
                fill(col.p.front);
                rect(-5 * this.scale, 0, 10 * this.scale, 12 * this.scale, 3 * this.scale);
            popMatrix();
        },
        arm2: function(t1, k1, t2, k2, x, y){
            noStroke();
            //rear
            pushMatrix();
                translate(x, y);
                rotate(t2);
                
                fill(col.p.rear);
                rect(-5 * this.scale, 0, 10 * this.scale, 25 * this.scale, 5 * this.scale);
                
                translate(0, 20 * this.scale);
                rotate(k2);
                
                noStroke();
                fill(col.p.skinColor);
                ellipse(0, 16 * this.scale, 8 * this.scale, 8 * this.scale);
                
                fill(col.p.rear);
                rect(-5 * this.scale, 0, 10 * this.scale, 12 * this.scale, 3 * this.scale);
            popMatrix();
        },
        head: function(x, y){
            //noStroke();
            pushMatrix();
                translate(x, y);
                fill(col.p.skinColor);
                ellipse(0, 1, 20 * this.scale, 20 * this.scale);
            popMatrix();
        },
        cloakFront: function(x, y){
            noStroke();
            let xMove = ((-Math.abs(this.v.x * 2) - 0) / 40) * 90;
            let yMove = 0;
            yMove = lerp(yMove, -this.v.y, 0.8);
            pushMatrix();
                translate(x, y);
                fill(col.p.cloak);
                ctx.beginPath();
    	        ctx.moveTo(-0.6, 4.0);
    	        bezierVertex(-18.7 + xMove, 21.0 + yMove * 2, 4.6 + xMove, 22.0 + yMove, 1 + xMove, 10 + yMove * 2);
                ctx.fill();
                //hood
                ctx.beginPath();
    	        ctx.moveTo(1, -3);
    	        bezierVertex(-6.7, 2.0, -5.0, 2.0, 1, 6);
                ctx.fill();
                
            popMatrix();
        },
        cloakRear: function(x, y){
            noStroke();
            let xMove = ((-Math.abs(this.v.x * 2) - 0) / 40) * 90;
            let yMove = 0;
            yMove = lerp(yMove, -this.v.y, 0.8);
            pushMatrix();
                translate(x + 4, y);
                fill(col.p.cloakRear);
                ctx.beginPath();
    	        ctx.moveTo(-2.9, 4.0);
    	        bezierVertex(-18.7 + xMove, 21.0 + yMove * 2, 4.6 + xMove, 22.0 + yMove, 1 + xMove, 10 + yMove * 2);
                ctx.fill();
            popMatrix();
        },
        body: function(x, y){
            noStroke();
            pushMatrix();
                translate(x, y);
                
                fill(col.p.cloths);
                rect(5 * this.scale, -14 * this.scale, 14 * this.scale, 34 * this.scale);
            popMatrix();
        },
        draw: function(){
            switch(this.action){
                case "walk": {
                    if(this.action !== "air"){
                        let s = this.walk[~~this.index%this.walk.length];
                        for(var i = 0; i < this.pos.length; i += 1){
                            this.pos[i] = lerp(this.pos[i], s[i]*this.emphasis, this.animSpeed);
                        }
                        let zed = this.walkArms[~~this.index%this.walkArms.length];
                        for(let i = 0; i < this.posArms.length; i += 1){
                            this.posArms[i] = lerp(this.posArms[i], zed[i]*this.emphasis, this.animSpeed);
                        }
                    }
                    break;
                }
                case "air": {
                    for(let i = 0; i < this.pos.length; i += 1){
                        this.pos[i] = lerp(this.pos[i], this.air[i], this.animSpeed);
                    }
                    break;
                }
                case "shoot": {
                    alert("shoot");
                    break;
                }
            }
            //idle
            if(this.action !== ("walk" || "air")){
                for(let i = 0; i < this.pos.length; i += 1){
                    this.posArms[i] = lerp(this.posArms[i], this.idleArms[i], this.animSpeed);
                }
                for(let i = 0; i < this.pos.length; i += 1){
                    this.pos[i] = lerp(this.pos[i], this.idle[i], this.animSpeed);
                }
            }
            //collision box
            //fill("rgba(255, 255, 255, 0.3)");
            //ctx.fillRect(this.x, this.y, this.w, this.h);
            
            //render actual player
            pushMatrix();
                translate(this.x + this.xOff, this.y + this.yOff);
                //negate cam              
                let alphaX = (mouse.x + cam.x - cam.align.x)/cam.z;
                let alphaY = (mouse.y + cam.y - cam.align.y)/cam.z;                  
                
                //reverse player transitions 
                let trueX = alphaX - this.x - this.xOff;
                let trueY = alphaY - this.y - this.yOff;
                txt = Math.floor(trueX) + ", " + Math.floor(trueY);
                fill("green");
                ellipse(trueX, trueY, 2, 2);
                
                scale(this.dir, 1);
                this.cloakRear(0, -52);
                this.arm2(this.posArms[0], this.posArms[1], this.posArms[2], this.posArms[3], 0, -49);
                this.leg1(this.pos[0], this.pos[1], this.pos[2], this.pos[3], 0, -42);
                this.leg2(this.pos[0], this.pos[1], this.pos[2], this.pos[3], 0, -42);
                this.body(-3, -46);
                //front arm and bow
                this.arm1(this.posArms[0], this.posArms[1], this.posArms[2], this.posArms[3], 0, -49);
                this.head(0, -52);
                
                this.cloakFront(0, -52);
            popMatrix();
            this.index += 0.1;
        },  
        move: function() {
            let acc = this.physics.acc;
            let friction = this.physics.friction;
            let jumpPow = this.physics.jumpPow;
            let gravity = this.physics.gravity;
            let speed = this.physics.speed;
            
            
            
            if(mouse.down){
                this.shoot = true;
            }
            else {
                this.shoot = false;
            }
            
            //vector movement
            if ((keys[37] || keys[65])) { 
                this.v.x -= acc; 
                if(!this.jump){
                    this.action = "air";
                }
                else if(Math.abs(this.v.x) > 0.1){
                    this.action = "walk";
                }
                else {
                    this.action = "idle";
                }
                this.dir = -1;
            }
            else if ((keys[39] || keys[68])) { 
                this.v.x += acc;
                if(!this.jump){
                    this.action = "air";
                }
                else if(Math.abs(this.v.x) > 0.1){
                    this.action = "walk";
                }
                else {
                    this.action = "idle";
                }
                this.dir = 1;
            }
            else { 
                this.v.x /= friction; 
                if(this.jump){
                    this.action = "idle";
                }
            }
            
            if ((keys[38] || keys[87]) && this.jump) {
                this.v.y = -jumpPow;
                this.action = "air";
            }
            
            //put stuff together
    		this.v.y += gravity;
            this.x += this.v.x;
            this.y += this.v.y;
            this.jump = false;
            this.v.x = constrain(this.v.x, -speed, speed);
            this.top = false;
        },
        
        //definitions
        display: function() {
            return this.draw();
        },
        update: function(){
            return this.move();
        },
    };
    
    //render if in range
    function range(n){
        if(dist(player.x, player.y, n.x, n.y) < blockSize * Math.sqrt(5)){
            return true;
        }
    }
    
    function roomName(){
        if(curColumn === 0 && curRow === 0 && curMap === CAVERNS){
            ctx.save();
                ctx.textAlign = 'center';
                ctx.fillStyle = "white";
                ctx.font = 'bold 30px Lato'
                ctx.fillText("The", 160, 310);
                ctx.font = 'bold 50px Lato'
                ctx.fillText("Desolate Caverns", 300, 350);
            ctx.restore();
        }
    }
    
    //block constructor 
    class Block {
        constructor(x, y, w, h, type, left, right, top, bottom, i) {
            this.x = x;
            this.y = y;
            this.w = w;
            this.h = h;
            this.type = type;
            //randomize
            this.seed = i;
            
            this.left = left;
            this.right = right;
            this.top = top;
            this.bottom = bottom;
        }
        draw() {
            switch(this.type){
                case "block": {
                    
                    ctx.save();
                        fill(col.bl.block2);
                        //ctx.globalAlpha = 0.8;
                        if(!this.bottom || !this.top || !this.left || !this.right){
                            //ctx.globalAlpha = 1;
                            fill(col.bl.block);
                        }
                        
                        rect(this.x, this.y, this.w, this.h);
                    ctx.restore();
                    
                    
                    //grass
                    if(!this.top){
                        fill(col.bl.grass);
                        triangle(
                            this.x, this.y, 
                            this.x + 2, this.y - 2 * this.seed, 
                            this.x + 4, this.y - 0
                        );
                        pushMatrix();
                        translate(2, 0);
                        triangle(
                            this.x, this.y, 
                            this.x + 2, this.y + -2 * this.seed, 
                            this.x + 4, this.y - 0
                        );
                        translate(4, 0);
                        triangle(
                            this.x, this.y, 
                            this.x + 2, this.y + -2, 
                            this.x + 4, this.y - 0
                        );
                        translate(-1, 0);
                        triangle(
                            this.x, this.y, 
                            this.x + 2, this.y + -2, 
                            this.x + 4, this.y - 0
                        );
                        translate(-2, 0);
                        triangle(
                            this.x, this.y, 
                            this.x + 2, this.y + -2 * this.seed, 
                            this.x + 4, this.y - 0
                        );
                        popMatrix();
                        if(this.left){
                            triangle(
                                this.x, this.y, 
                                this.x, this.y + -2, 
                                this.x + 4, this.y - 0
                            );
                        }
                        if(this.right){
                            triangle(
                                this.x + 10, this.y, 
                                this.x + 10, this.y + -2, 
                                this.x + 8, this.y - 0
                            );
                        }
                    }
                    
                    //collisions
                    Physics.collideBox.all(player, this);
                    //Physics.collideBox.all(player, this);
                    if(Physics.collideBox.top(player, this)){
                        player.top = true;
                    }
                    
                    break;
                }
                case "poison": {
                    fill(col.bl.poison);
                    
                    //constants special to this block
                    let speed = 17.786;
                    let zed = 1;
                    
                    //if not the top block
                    if(!this.top){
                        //start
                        triangle(this.x, this.y, this.x, this.y + (Math.sin(frameCount/speed) - zed), this.x + 4, this.y - 0);
                        //center
                        triangle(this.x, this.y, this.x + 6, this.y + (Math.cos(frameCount/(speed * this.seed)) - zed), this.x + 10, this.y - 0);
                        triangle(this.x + 3, this.y, this.x + 6, this.y + (Math.sin(frameCount/(this.seed * 10)) - zed), this.x + 9, this.y - 0);
                        
                        //finish
                        triangle(this.x + 4, this.y, this.x + 10, this.y + (Math.sin(frameCount/speed) - zed), this.x + 10, this.y - 0);
                        
                        poisonParticles.add(this.x, this.y, this.w, this.h);
                    }
                    
                    ctx.fillRect(this.x, this.y, this.w, this.h);
                    //collisions
                    //if(range(this)){
                        if(Physics.collideBox.touch(player, this)){ 
                            //poisonSplash.run(this.x, this.y, this.w, this.h);
                            player.die = true;
                            
                            
                        }
                    //}
                    break;    
                }
                case "pipe": {
                    //a new collision object
                    let that = {
                        x: 0,
                        y: 0,
                        w: 0,
                        h: 0,
                    };
                    
                    //left pipe
                    if(this.left){
                        //particle stream
                        poisonStream.add(this.x + this.w - 4, this.y + this.h - 4, 0.5, 30);
                        
                        fill(col.bl.pipe2);
                        ctx.fillRect(this.x, this.y, this.w, this.h);
                        fill(col.bl.pipe1);
                        ctx.fillRect(this.x, this.y, this.w, this.h/2);
                        //a second collision object
                        that = {
                            x: this.x + this.w - this.w/5,
                            y: this.y - 2.5,
                            w: this.w/5,
                            h: this.h*1.5,
                        };
                        ctx.fillRect(that.x, that.y, that.w, that.h);
                        
                    }
                    //right pipe
                    if(this.right){
                        poisonStream.add(this.x, this.y + this.h - 4, -0.5, 30);
                        fill(col.bl.pipe2);
                        ctx.fillRect(this.x, this.y, this.w, this.h);
                        fill(col.bl.pipe1);
                        ctx.fillRect(this.x, this.y, this.w, this.h/2);
                        that = {
                            x: this.x,
                            y: this.y - 2.5,
                            w: this.w/5,
                            h: this.h*1.5,
                        };
                        ctx.fillRect(that.x, that.y, that.w, that.h);
                    }
                    
                    Physics.collideBox.all(player, this);
                    Physics.collideBox.all(player, that);
                }
            }
        }
    };
    
    //auto tiling and orientation of blocks (see the pipe)
    const tiled = {
        left: function(MAP, row, col, char, char2){
            //if(MAP[row][col] === char){
                if(MAP[row][col - 1] === char){
                    return true;
                } 
            //}
        },
        right: function(MAP, row, col, char){
            //if(MAP[row][col] === char){
                if(MAP[row][col + 1] === char){
                    return true;
                }
            //}
        },
        bottom: function(MAP, row, col, char){
            //if(MAP[row][col] === char){
                if(row < MAP.length - 1){
                    if(MAP[row + 1][col] === char){
                        return true;
                    }
                }
            //}
        },
        top: function(MAP, row, col, char){
            //if(MAP[row][col] === char){
                if(row > 0){
                    if(MAP[row - 1][col] === char){
                        return true;
                    }
                }
            //}
        },
    };
    
    //map constructor 
    const mapSetup = (function(lvl) {
        blocks = [];
        const MAP = lvl;
        let longestX = 0;
        for (let i = 0; i < MAP.length; i++) {
            for (let j = 0; j < MAP[i].length; j++) {
                switch (MAP[i][j]) {
                    //The blocks, these all have to be one liners because stated if statements and local variables will be called many, many times. My apologies
                    case "#": {
                        blocks.push(new Block(j * blockSize, i * blockSize, blockSize, blockSize, "block", tiled.left(MAP, i, j, "#"), tiled.right(MAP, i, j, "#"), !tiled.top(MAP, i, j, "#") && !tiled.top(MAP, i, j, "-") ? false: true, tiled.bottom(MAP, i, j, "#"), Math.random() * (1.4 - 0.6) + 0.6));
                        break;
                    }
                    case "-": {
                        blocks.push(new Block(j * blockSize, (i * blockSize) + (tiled.top(MAP, i, j, "-") ? 0: 3), blockSize, blockSize, "poison", tiled.left(MAP, i, j, "-"), tiled.right(MAP, i, j, "-"), tiled.top(MAP, i, j, "-"), tiled.bottom(MAP, i, j, "-"), Math.random() * (0.9 - 0.3) + 0.3));
                        break;
                    }
                    case "P": {
                        blocks.push(new Block(j * blockSize - (tiled.right(MAP, i, j, "#") ? blockSize: 0), (i * blockSize), blockSize * 2, blockSize, "pipe", tiled.left(MAP, i, j, "#"), tiled.right(MAP, i, j, "#"), tiled.top(MAP, i, j, "#"), tiled.bottom(MAP, i, j, "#"), Math.random() * (0.9 - 0.3) + 0.3));
                        break;
                    }
                }
            }
            if(MAP[i].length>longestX){
                longestX = MAP[i].length;
            }
        }
        //fetch the width and height of each level in pixels
        lvlSizeX = longestX*blockSize;
        lvlSizeY = MAP.length*blockSize;
    });
    
    //starting position and map
    mapSetup(curMap[functions.startPos.row][functions.startPos.col]);
    player.x = functions.startPos.x;
    player.y = functions.startPos.y;
    
    //camera redefinition 
    cam = {
        //the cam position
        x: 0, 
        y: 0,
        //the scale
        z: 3,
        //the camera alignment, a level is 100x100 pixels
        align: {
            x: 100,
            y: 100,
        },
        //run the cam
        run: function(){
            //update the cam based on player coords
            this.x += ((player.x - this.x) / 10) || 0;
            this.y += ((player.y - this.y) / 15) || 0;
            
            //constrain the camera values from the alignment shift to the level size
            this.x = constrain(this.x, this.align.x, lvlSizeX - this.align.x);
            this.y = constrain(this.y, this.align.x, lvlSizeY - this.align.y);
            //transformation, bitcase to remove the nasty lines between blocks 
            scale(this.z);
            translate(~~(-this.x + this.align.x + shake.x), ~~(-this.y + this.align.y + shake.y));
            
        },
    };
    
    //ctx.getImageData(xPos, yPos, width, height);
    //
    
    var Explosian = (function () {
        var explode = function (x, y, w, h, parSize) {
            this.x = x;
            this.y = y;
            this.w = w;
            this.h = h;
            this.parSize = parSize;
            
            this.img();
            this.ImgArr = [];
                this.array = this.getImgs();
        };
        explode.prototype = {
            lrp: function(to, from, cushion){
                return (to - from) / cushion;
            },
            runParticles: function(par){
                for(var i = 0; i < par.length; i++){
                    pushMatrix();
                        ctx.translate(par[i].x, par[i].y);
                        rotate(par[i].r);
                        ctx.translate(-this.parSize/2, 0);
                        //image(par[i].i, 0, 0);
                        ctx.putImageData(par[i].i, par[i].x, par[i].y, 0, 0, this.parSize, this.parSize);
                    popMatrix();
                    var acc = 1.1;
                    acc++;
                    par[i].r += par[i].s/30;
                    par[i].y += par[i].vy * acc;
                    par[i].y += par[i].vy * acc;
                    par[i].x += par[i].vx * acc;
                }
            },
            getImgs: function(){
                for(var i = this.x; i < this.x + this.w; i += this.parSize){
                    for(var j = this.y; j < this.y + this.h; j += this.parSize){
                        this.ImgArr.push({
                            //fetch a chunks of the image
                            i: ctx.getImageData(i, j, this.parSize, this.parSize),
                            //velocity is random
                            vx: random(-2, 2), 
                            vy: random(-2, 2), 
                            //rotation
                            r: 0, 
                            rs: random(-2, 2), 
                            //particle speed
                            s: random(20, 40), 
                            //starting place
                            x: i, 
                            y: j, 
                        });
                    }
                }
                return this.ImgArr;
            },
            img: function(){
                //transparent background
                background("rgba(255, 255, 255)");
                //the image input
                fill("orange");
                rect(this.x, this.y, this.w, this.h);
            },
            run: function(){
                this.runParticles(this.array);
            },
        };
        return explode;
    })();

    //x, y, w, h, image, particle size
    var e = new Explosian(200, 200, 100, 100, 20);
    
    
    
    //animation loop
    const render = () => {
        //initilize frame counter
        frameCount++;
        
        //blank canvas
        background(col.bg);
        
        wind.add();
        wind.run();
        
        //start image cache
        cache.load();
        
        //the equivilant of pushMatrix and popMatrix
        ctx.save();
            cam.run();
            
            //shakes.push(new Shake(2));
            
            //cam shake loop
            for(let s = 0; s < shakes.length; s++){
                shakes[s].active(s);
            }
            
            //player
            player.display();
            if(functions.plUpdate){
                player.update();
            }
            
            
            poisonParticles.run();
            poisonStream.run();
            
            //running this before the blocks allows me to capture the player only when doing a death animation
            functions.execute(player);
            
            //blocks
            for (let i = 0; i < blocks.length; i++) {
                blocks[i].draw();
            }
        ctx.restore();
        
        roomName();
        
        //overlay
        img(cache.img[0], 0, 0);
        
        e.run(); 
        
        //reset events
        mouse.released = false;
        mouse.clicked = false;
        
        ctx.font = "25px Arial";
        ctx.fillStyle = "white";
        ctx.fillText(txt, 10, 30);
        ctx.fillText(err, 10, 50);
        
        //thumb
        if(keys[84]){
            background("rgb(255, 255, 255)");
        }
        window.requestAnimationFrame(render);
    };
    render();
    
    
    /**
    window.addEventListener("resize", function() {
	    var globalHeight = (document.body.clientHeight);
	    var globalWidth = (document.body.clientWidth);
	    canvas.style.height = globalHeight + "px";
	    canvas.style.width = globalWidth + "px";
	    alert(canvas.style.width);
    });
	const openInFullscreen = () => {
		const w = window.open();
		w.document.open();
		w.document.write(`<!doctype html><html>${document.querySelector('html').innerHTML}</html>`);
		w.document.close();
	}
	// get our button
	const button = document.getElementById('fullscreen');
	// add the event listener
	button.addEventListener('click', openInFullscreen);
    **/
    /**
    window.openInFullscreen = function(){
        var w = window.open();
        
        let pageCode = "";
        pageCode += "<html><head><script>";
        pageCode += "var KAInfiniteLoopProtect = function(){};";
        pageCode += "</scr" + "ipt>";
        pageCode += document.getElementsByTagName("head")[0].innerHTML;
        pageCode += "</head><body>";
        pageCode += document.getElementsByTagName("body")[0].innerHTML;
        pageCode += "</body></html>";
        
        
        w.document.open();
        w.document.write(pageCode);
        w.document.close();
    };
            
    document.body.addEventListener("click", function(){
        if(width <= 4000){
            window.openInFullscreen();
        }
    
        else{
            let fullScreen = window.innerWidth === screen.width && window.innerHeight === screen.height;
    
            if(fullScreen){
                if(document.exitFullscreen){
                    document.exitFullscreen();
                }
    
                // safari
                else if(document.webkitExitFullscreen){
                    document.webkitExitFullscreen();
                }
    
                // MS edge
                else if(document.msExitFullscreen){
                    document.msExitFullscreen();
                }
            }
            else{
                if(document.body.requestFullscreen){
                    document.body.requestFullscreen();
                }
    
                // safari
                else if(document.body.webkitRequestFullscreen){
                    document.body.webkitRequestFullscreen();
                }
    
                // MS edge
                else if(document.body.msRequestFullscreen){
                    document.body.msRequestFullscreen();
                }
            }
        }
    });
    **/
}
catch(e){
    console.log(e);
    //alert(e.stack)
}
        //<script>        
    </script>
</html>

<!--
Easter egg ideas:

You get stuck and rick rolled by the narrator lol

-->



